#+OPTIONS: num:nil author:nil timestamp:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

** No.152

$a + b + c \leq \lfloor L/4 \rfloor$ となるピタゴラス数を数え上げる。

ピタゴラス数の数え上げは

$(a, b, c) = (m^2 - n^2, 2mn, m^2 + n^2)$ (ただし、$m \gt n$, $m$ と $n$ は互いに素、$m - n$ は奇数)

を使う。$2m^2 \leq L/4$ であるから、$m$ は最大でも $10^3$ 強である。

** No.153

grundy 数を計算する。

$g(1) = 0$ であり、山が $x_1, x_2$ 個の山に分裂したときの grundy 数は $g(x_1) \oplus g(x_2)$ となる。

** No.154

後ろの文字から見ていき、Rが通過した系統数 $R$ 、Gが通過した系統数 $G$ 、Wが通過した系統数 $W$ をメモしておく。文字によってメモを以下のように更新する。

- Rのときは $R$ に $1$ を加える。
- Gのときは $G \geq R$ ならば impossible。そうでなければ $G$ に $1$ を加える。
- Wのときは $G = 0$ ならば impossible。そうでなければ $W$ に $1$ を加える。ただし加えた結果 $W \gt G$ となる場合は加えない。

最後まで見終わったときに $R = G = W$ ならば possible、そうでなければ impossible である。

** No.156

実装あるのみ。

** No.157

空洞をひとつ選び、そこから空洞を深さ(幅)優先探索で探索してかたまり1を確定させる。

残りの中から空洞をひとつ選び、そこから深さ(幅)優先探索でかたまり2を確定させていく。探索の途中で壁があった場合は、そこから幅優先探索でかたまり1にたどり着くまでの最短距離を求める。

すべての最短距離の最小値が答えである。

** No.158

手持ちが $(A_{1000}, A_{100}, A_1)$ のときに行ける最大のお使い回数を返す関数を作り、メモ化再帰する。

$D$ 円を払うための1000円、100円、1円の使い方は、大きい方のお金から使うようにすればいい。合計金額が足りているがちょうど払えない場合は大きい方のお金を持っているときだからである。

** No.159

以下の計算式になる。

\begin{align*}
P_1 &= (1-p)q \\
P_2 &= p(1-q)q
\end{align*}

$q \neq 0$ であるので、$q$ で割っておいていい。

** No.160

ダイクストラ法で各駅からゴールまでの最小距離を求める。

その後、スタートから辞書順で小さい番号の駅でゴールまでの最小距離が一致する駅を順にたどる。

** No.161

友人の手に勝てるカードをできるだけ出し、その後引き分けになるカードをできるだけ出す。

** No.163

実装あるのみ。

** No.164

文字列を $n$ 進数と解釈したときに最小にするには、$n$ をできるだけ小さくするように取ればいい。

** No.165

座標圧縮をしておく。

X軸方向の範囲は全探索し、Y軸方向の範囲はしゃくとり法で探索する。

** No.166

番号は $0$ から振られるものとして $K$ を調整しておく。

$HW - 1$ を $N$ で割った余りが $K$ ならば $K$ 番目の人は負けである。

** No.167

下一桁の数字と累乗数の関係は以下の通りである。

|   | 1 | 2 | 3 | 4 | 5 |
|---+---+---+---+---+---|
| 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 2 | 4 | 8 | 6 | 2 |
| 3 | 3 | 9 | 7 | 1 | 3 |
| 4 | 4 | 6 | 4 | 6 | 4 |
| 5 | 5 | 5 | 5 | 5 | 5 |
| 6 | 6 | 6 | 6 | 6 | 6 |
| 7 | 7 | 9 | 3 | 1 | 7 |
| 8 | 8 | 4 | 2 | 6 | 8 |
| 9 | 9 | 1 | 9 | 1 | 9 |

すべて周期4で循環しているので、$N$ の下一桁と $M$ を $4$ で割った余りだけ見ればいい。
なお、$M$ を $4$ で割った余りを計算するためには $M$ の下二桁だけ見ればいい。

コーナーケースとして、$M = 0$ のときは $N^M = 1$ である。

** No.168

二点間の距離はあらかじめ求めておく。

長さ $L$ のものさしを使ったとき、$P_1$ から $P_N$ を結べるかどうかは、Union-Find 法を使う。

$P_i, P_j$ 間の長さが $L$ 以下なら辺を追加していって、$P_1$ と $P_N$ が同じグループに属するかどうかを見る。

そして、$L$ を二分探索で求める。

** Local variables                                                 :noexport:

# Local variables:
# after-save-hook: org-html-export-to-html
# end:
