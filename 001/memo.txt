-- No.1

[n番目の町,かかったコスト] をキーにして最小の到達時間を保持する配列を用意し、DPで最初の町から順番に
更新していく。

同じ町間で複数の道がある場合があるので注意。

-- No.2

素因数分解したときの各素因数の累乗数を使ったNimである。

-- No.3

訪れた数字をメモしておいて、訪れていない数字を幅優先探索で辿っていく。

-- No.4

すべてのおもりの重さの合計の半分の重さを作れるかどうかを調べる。

おもりの重さの合計をキーにしたその重さを作れるかどうかを保持する配列を用意し、DPで最初のおもりから順
番に更新していく。

-- No.5

ブロックを昇順にソートし、貪欲法で箱に入れていく。

-- No.6

素数列とハッシュ列はあらかじめ求めておく。
しゃくとり法で最大の長さを探す。

-- No.7

各数字のgrundy数を順に計算していく。

-- No.8

N=1 (mod K+1) を相手に渡せれば勝てる。したがって、Nがすでにその数字であれば負け、そうでなければ勝ち
である。

-- No.9

自分のモンスターを優先順位付きキューに入れておいてレベルが低い順に取り出せるようにする。
どの敵モンスターから戦うかを全探索して最小の最多戦闘回数を求める。

-- No.11

マークの種類x数字の表を作り手札を埋めると、マッチするカードは埋められた手札と同じ行/列のマスである。
マッチするマスが上/左にくるように行/列の入れ替えを行うと、マッチするカードの枚数は面積で求められる。

-- No.12

素数列をあらかじめ求めておく。

素数列を走査して使ってもいい数字だけを使っている部分列をなるべく長くなるように抜き出し、その部分列が
使ってもいい数字をすべて使っているなら、その素数列の前後の素数の差-2を保存しておく。

保存された素数の差の最大値が答えである。

-- No.13

未訪問のマスから始めて同じ数字を持つマスを深さ優先探索(幅優先探索)で辿っていき、直前に辿ったマス以外
で訪問済のマスに辿りついた場合は囲みができているということである。
これを未訪問のマスがなくなるまで続ける。

-- No.16

x^(2^n)をあらかじめ計算しておく。a_kを2^mの和に分解(2進数に変換して立っているビットを取得)して、
計算しておいたx^(2^n)を足していく。

-- No.17

すべての地点間の距離をワーシャル・フロイド法で求めておく。
1番目に滞在する地点と2番目に滞在する地点で全探索する。

-- No.18

実装あるのみ。

-- No.20

まずスタートからゴールまで直接行けるかどうかを調べる。
行けない場合、オアシスを経由して行けるかどうかを調べる。
2地点間の体力の消費量はダイクストラ法で求める。

-- No.21

{最大値},{最小値},{残り} とグループ分けしたときが最も平均の差が大きくなる。すなわち最大値と最小値の
差を計算すればいい。

-- No.22

K文字目が'('ならば、K文字目から順番に走査していき、'('なら+1、')'なら-1を累計していく。累計が0に戻っ
たときの文字が対応するカッコである。
K文字目が')'ならば、K文字目から逆順に走査する。

-- No.23

合計Nのダメージを与えるのに必要な攻撃回数の期待値をE(N)とすると、

  E(N) = min(E(N - A) + 1, E(N - D) + 3/2)
  ただし E(n) = 0 (n <= 0)

である。

-- No.24

0~9からなる候補配列を用意しておき、二郎君の答えが'YES'ならば提示した数字と候補配列のANDをとり、二郎
君の答えが'NO'ならば候補配列から提示した数字を取り除く。
残った数字が答えである。

-- No.25

N, Mは約分しておく。

NがMで割り切れるなら0以外の一番下の桁が答えである。
NがMで割り切れない場合、Mの素因数に2,5以外が含まれていれば無限小数である。

Mの素因数に2,5のみが含まれている場合、Mが10^nになるようにN,Mに2^m,5^lをかけて、そのときのNの0以外の
一番下の桁が答えとなる。

-- No.26

実装あるのみ。

-- No.27

長さA,B,Cの板から長さVの板を作るための最小枚数は、長さをキーにした最小枚数を保持する配列を用意してDPで
求める。

あとはA,B,Cを1~30まで全探索(ただし、A<=B<=Cと仮定しても良い)して最小の枚数を求める。

-- No.29

2個あるアイテムを優先で使う。残ったアイテムで4つ組ができればさらに使う。

-- No.30

製品kを作るために必要な製品数一覧を返す関数を作り、メモ化再帰する。

-- No.32

小さい金額の硬貨から順番に1つ大きい金額の硬貨に両替していく。

-- No.33

XiをDで割った余りが異なるアメーバ同士は互いに干渉しない。
したがって、XiをDで割った余りでグループ分けして、グループごとに計算する。

グループ分けされたXiはDで割って座標圧縮しておく。
そうするとXkの位置にいたアメーバはT秒後に Xk-T ~ Xk+T の範囲に広がる。
Xiごとにこれを計算し、重なっている範囲を除けばいい。
このとき、Xiを昇順にソートしておくと、重なりのチェックは直前のXi-1のアメーバだけを対象にすればよくなる。

-- No.34

幅優先探索とDPを組み合わせる。
ある地点pまでたどり着くまでの最小の体力をV(p)とする。
幅優先探索で、探索元pを、探索先をqとすると、V(p)+L(q)<V(q)のときに探索先は有効となる。

-- No.35

実装あるのみ。

-- No.36

素因数分解したときに素因数(重複を許す)の数が3つ以上あればいい。

-- No.39

一番上の桁から、その桁より下の桁の数字の最大値を求める。
その桁の数字より最大値が大きいならば、その最大値を持つ桁のうち最も下の桁と入れ替えて、答えとなる。
そうでないならば次の桁を調べ、以下繰り返す。

-- No.40

実装あるのみ。

-- No.43

行われていないゲームのすべての勝ち負けの組み合わせについて順位を求め、その最小値を求める。

-- No.44

マスの番号をキーにそのマスにたどり着く組み合わせの数の配列を用意し、最初のマスから順番に更新していく。
漸化式はフィボナッチ数列になる。

-- No.45

[n番目の寿司、n番目の寿司を取ったかどうか]をキーにして最大価値を保持する配列を用意して、DPで順番に更
新していく。

-- No.46

割り算して小数点以下を切り上げる。

-- No.47

N = 2^n ならばnが答えである。
N = 2^n+k ならば、n回ポケットを叩いた後、ポケットにk枚残してポケットを叩けばいいので、n+1が答えであ
る。

-- No.48

移動をする操作の回数は割り算(小数点以下切り上げ)で求める。
回転をする操作の回数は、x > 0 のy軸上なら0回、y >= 0 なら1回、y < 0 なら2回である。

-- No.49

正規表現 ([+*]?)(\d+) で走査する。
