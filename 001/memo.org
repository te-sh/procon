#+OPTIONS: num:nil author:nil timestamp:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

** No.1

$i$ 番目の町にコスト $c$ で到達したときの到達時間を $T$ として、$i$ 番目の町から $j$ 番目の町にたどり着くためのコストと時間を $C_{ij}$, $M_{ij}$ とすると、

\[ T(j, c + C_{ij}) = min(T(i, c) + M_{ij}) \]

となる。ただし、$i$ は $j$ へつながっている町すべてをたどる。これを DP で計算し、$T(N, \ast)$ の最小値を求める。

** No.2

素因数分解したときの各素因数の累乗数を使った Nim である。

** No.3

訪れた数字をメモしておいて、訪れていない数字を幅優先探索で辿っていく。

** No.4

すべてのおもりの重さの合計の半分の重さを作れるかどうかを調べる。

$i$ 番目のおもりまで調べたときにおもりの重さの合計 $W$ を作れるかどうかを $B(i, W)$ とすると、

\[ B(i, W) = B(i - 1, W) \land B(i - 1, W + W_i) \]

となる。これを DP で計算し、$B(N, \sum W_i/2)$ を見る。

** No.5

ブロックを昇順にソートし、貪欲法で箱に入れていく。

** No.6

素数列とハッシュ列はあらかじめ求めておく。
しゃくとり法で最大の長さを探す。

** No.7

各数字のgrundy数を順に計算していく。

** No.8

$N \equiv 1 \pmod{K+1}$ を相手に渡せれば勝てる。したがって、$N$ がすでにその数字であれば負け、そうでなければ勝ちである。

** No.9

自分のモンスターを優先順位付きキューに入れておいてレベルが低い順に取り出せるようにする。

どの敵モンスターから戦うかを全探索して最小の最多戦闘回数を求める。

** No.11

マークの種類 \times 数字の表を作り手札を埋めると、マッチするカードは埋められた手札と同じ行/列のマスである。

マッチするマスが上/左にくるように行/列の入れ替えを行うと、マッチするカードの枚数は面積で求められる。

** No.12

素数列をあらかじめ求めておく。

素数列を走査して使ってもいい数字だけを使っている部分列をなるべく長くなるように抜き出し、その部分列が
使ってもいい数字をすべて使っているなら、その素数列の前後の素数の差-2を保存しておく。

保存された素数の差の最大値が答えである。

** No.13

未訪問のマスから始めて同じ数字を持つマスを深さ優先探索(幅優先探索)で辿っていき、直前に辿ったマス以外で訪問済のマスに辿りついた場合は囲みができているということである。

これを未訪問のマスがなくなるまで続ける。

** No.16

$x^{2^n}$ をあらかじめ計算しておく。$a_k$ を $2^m$ の和に分解(2進数に変換して立っているビットを取得)して、計算しておいた $x^{2^n}$ を足していく。

** No.17

すべての地点間の距離をワーシャル・フロイド法で求めておく。

1番目に滞在する地点と2番目に滞在する地点で全探索する。

** No.18

実装あるのみ。

** No.20

まずスタートからゴールまで直接行けるかどうかを調べる。行けない場合、オアシスを経由して行けるかどうかを調べる。

2地点間の体力の消費量はダイクストラ法で求める。

** No.21

{最大値}, {最小値}, {残り} とグループ分けしたときが最も平均の差が大きくなる。すなわち最大値と最小値の差を計算すればいい。

** No.22

$k$ 文字目が ='('= ならば、$k$ 文字目から順番に走査していき、 ='('= なら $+1$ 、 =')'= なら $-1$ を累計していく。累計が $0$ に戻ったときの文字が対応するカッコである。

$k$ 文字目が =')'= ならば、K文字目から逆順に走査する。

** No.23

合計 $N$ のダメージを与えるのに必要な攻撃回数の期待値を $E(N)$ とすると、

\[ E(N) = \min(E(N - A) + 1, E(N - D) + 3/2) \]

となる。ただし $n \leq 0$ のとき $E(n) = 0$ である。これを DP で計算し、$E(N)$ を見る。

** No.24

$0 \dots 9$ からなる候補配列を用意しておき、二郎君の答えが 'YES' ならば提示した数字と候補配列の AND をとり、二郎君の答えが 'NO' ならば候補配列から提示した数字を取り除く。

残った数字が答えである。

** No.25

$N,M$ は約分しておく。

$N$ が $M$ で割り切れるなら $0$ 以外の一番下の桁が答えである。

$N$ が $M$ で割り切れない場合、$M$ の素因数に $2,5$ 以外が含まれていれば無限小数である。

$M$ の素因数に $2,5$ のみが含まれている場合、$M$ が $10^n$ になるように $N,M$ に $2^m,5^l$ をかけて、そのときの $N$ の $0$ 以外の一番下の桁が答えとなる。

** No.26

実装あるのみ。

** No.27

長さ $a_i \; (i=1,2,3)$ の板から長さ $V$ の板を作るための最小枚数を求める方法は次の通りである。

$i$ 番目の板までを使ったときに長さ $L$ の板を作るための最小枚数を $N(L)$ とすると、

\[ N(i, L) = min(N(i - 1, L), N(i - 1, L - ka_i) + k) \]

となる。ただし、$k$ は $L-ka_i$ が $0$ 以上となる範囲をたどる。これを DP で計算し、$N(3, V)$ を見る。

あとは $A,B,C$ を $1 \dots 30$ まで全探索(ただし、$A \leq B \leq C$ と仮定しても良い)して最小の枚数を求める。

** No.29

2個あるアイテムを優先で使う。残ったアイテムで4つ組ができればさらに使う。

** No.30

製品 $i$ を作るために必要な製品数一覧を返す関数を作り、メモ化再帰する。

** No.32

小さい金額の硬貨から順番に1つ大きい金額の硬貨に両替していく。

** No.33

$X_i$ を $D$ で割った余りが異なるアメーバ同士は互いに干渉しない。

したがって、$X_i$ を $D$ で割った余りでグループ分けして、グループごとに計算する。

グループ分けされた $X_i$ は $D$ で割って座標圧縮しておく。

そうすると $X_k$ の位置にいたアメーバは $T$ 秒後に $X_k-T \dots X_k+T$ の範囲に広がる。

$X_i$ ごとにこれを計算し、重なっている範囲を除けばいい。

このとき、$X_i$ を昇順にソートしておくと、重なりのチェックは $X_{i-1}$ のアメーバだけを対象にすればいい。

** No.34

幅優先探索と DP を組み合わせる。

ある地点 $p$ までたどり着くまでの最小の体力を $V(p)$ とする。

幅優先探索で、探索元を $p$ 、探索先を $q$ とすると、$V(p)+L(q) \lt V(q)$ のときに探索先は有効となる。

** No.35

実装あるのみ。

** No.36

素因数分解したときに素因数(重複を許す)の数が3つ以上あればいい。

** No.37

$i$ 番目のアトラクションに2回目以降に乗ったときの満足度を計算し、$ci, vi$ に追加しておく。

このとき、2回目に乗るためには1回目に乗る必要があるといった考慮は必要ない。なぜならば、最大満足度を得るためには2回目に乗るときには1回目はすでに乗っているはずだからである。

あとは経過時間 $t$ のとき、$i$ 番目のアトラクションまで調べたときの最大満足度を $V(t,i)$ とすると、

\[ V(t,i) = \max(V(t, i - 1), V(t - ci, i - 1) + vi) \]

となり、これを DP で計算して、$V(\ast, (ciの長さ))$ の最大値を計算する。

** No.38

RとBは合わせて20個なのでどのRとBを使うかで全探索する。

** No.39

一番上の桁から、その桁より下の桁の数字の最大値を求める。

その桁の数字より最大値が大きいならば、その最大値を持つ桁のうち最も下の桁と入れ替えて、答えとなる。

そうでないならば次の桁を調べ、以下繰り返す。

** No.40

実装あるのみ。

** No.41

$M$ を111111で割った余りは必ず1円で払わなくてはいけない。

$M$ を111111で割った数(小数点以下切り捨て)を $N$ とすると、$N$ 円を1円玉A,1円玉B,2円玉,3円玉, $\dots$ ,9円玉で支払う方法の組み合わせを求める問題となる。

$n$ 円を $k$ 円玉以下で支払う方法の組み合わせを $C(n,k)$ とすると、

\[ C(n,k) = C(n,k-1) + C(n-k,k) \]

となり、これを DP で計算して $C(N,9)$ を見る。

** No.43

行われていないゲームのすべての勝ち負けの組み合わせについて順位を求め、その最小値を求める。

** No.44

$i$ マス目にたどり着く組み合わせの数を $C(i)$ とすると、

\[ C(i) = C(i-1) + C(i-2) \]

となる。これはフィボナッチ数列である。

** No.45

$i$ 番目の寿司まで流れてきたときの最大満足度を $V(i)$ とすると、

\[ V(i) = \max(V(i - 1), V(i - 2) + V_i) \]

となり、これを DP で計算して $V(N)$ を見る。

** No.46

割り算して小数点以下を切り上げる。

** No.47

$N = 2^n$ ならば $n$ が答えである。

$N = 2^n+k$ ならば、$n$ 回ポケットを叩いた後、ポケットに $k$ 枚残してポケットを叩けばいいので、$n+1$ が答えである。

** No.48

移動をする操作の回数は割り算(小数点以下切り上げ)で求める。

回転をする操作の回数は、$x \gt 0$ の $y$ 軸上なら $0$ 回、$y \geq 0$ なら $1$ 回、$y \lt 0$ なら2回である。

** No.49

正規表現 =([+*]?)(\d+)= で走査する。

** No.50

箱は降順にソートしておく。

$i$ 番目の箱までを使って、$p$ のおもちゃの集合を入れられるかどうかを $B(i, p)$ とし、$q$ のおもちゃの集合を $i$ 番目の箱に入れられるかどうかを $C(i, q)$ とすると、

\[ B(i + 1, p \cup q) = B(i, p) \lor C(i + 1, q) \]

となる。ただし、$p \cap q = \emptyset$ である。これを DP で計算し、$B(k, P)$ が真となっている最小の $k$ を求める。ただし、$P$ はすべてのおもちゃの集合である。

集合をビットで表現すると $p$ も $q$ も数字で表せる。

** Local variables                                                 :noexport:

# Local variables:
# after-save-hook: org-html-export-to-html
# end:
