#+OPTIONS: num:nil author:nil timestamp:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

** No.51

実装あるのみ。

制約から $D^2$ が =int= を超える可能性があるので =long= を使う。

** No.52

$k$ 回目に前から取るか後ろから取るかで全探索する。

** No.55

$P_1(X1, Y1), P_2(X2, Y2), P_3(X3, Y3)$ とする。

$P_1,P_2,P_3$ の順序を入れ替えて、すべての入れ替えパターンで正方形が1つでもできるかどうかを調べる。

$\vec{v_1}=\overrightarrow{P_1P_2}$, $\vec{v_2}=\overrightarrow{P_2P_3}$ とすると、正方形ができるためには次の条件が成り立つ必要がある。

\[ |\vec{v_1}| = |\vec{v_2}| \]

\[ \vec{v_1} \cdot \vec{v_2} = 0 \]

このとき、$P_1, P_4$ の位置ベクトルを $\vec{p_1}, \vec{p_4}$ とすると、

\[ \vec{p_4} = \vec{p_1} + \vec{v_2} \]

となる。

** No.56

\(D(100 + P) / 100\) で求められる。

$D (100 + P)$ が =int= を超える可能性があるので =long= を使う。

** No.57

1つのサイコロを振ったときの出る目の期待値は $3.5$ である。

各サイコロは独立なので、$N$ 個のサイコロを振った時に出る目の和の合計の期待値は各サイコロを振った時の目の和の期待値の合計 $3.5N$ となる。

** No.58

モンテカルロ法を使って実装あるのみ。

** No.59

Binary Indexed Tree (BIT) を使う。

インデックスには荷物の重さを使い、重さ $W$ の荷物を積む(降ろす)ときには BIT のインデックス $W$ を +1(-1) する。

** No.60

各位置ごとに合計でどれだけの攻撃があったかを imos 法で計算しておく。

その後、モンスターごとに HP が残るかどうかを調べ、残るならその合計を計算する。

** No.61

空間を下のように折り返して上下左右ともに2倍に拡張する。

|------------+--------------|
| 上下反転   | 上下左右反転 |
| オリジナル | 左右反転     |
|------------+--------------|

ただし、左右の端および上下の端はつながっているものとする。こうすることで反射を考えなくてもよくなる。

次に、$V_x,V_y$ を $g = \gcd(V_x, V_y)$ で割り、$D$ を $g$ 倍しておく。これで単位時間ごとに軌道上の格子点をすべて通るようになる。

あとはシミュレーションを行い、時間 $D$ 内にどの格子点を通るか調べればいい。ただし、すでに通った点にたどり着いた場合は以降も同じ軌道を通るのでシミュレーションを打ち切る。

** No.63

$L$ が2で割り切れない場合または $L/2$ が $K$ で割り切れない場合は、$\lfloor \lfloor L/2 \rfloor /K \rfloor$ 回かじる。

そうでない場合は1回少なくかじる。

** No.64

\begin{align*}
F_{k+3} &= F_{k+2} \oplus F_{k+1} \\
        &= (F_{k+1} \oplus F_{k}) \oplus F_{k+1} \\
        &= (F_{k+1} \oplus F_{k+1}) \oplus F_{k} \\
        &= F_{k}
\end{align*}

となるので、$F_k$ は周期3で循環している。

** No.65

問題に書かれている計算式にしたがって計算する。

** No.66

$i$ 番目の人が $j$ 回戦を勝ち抜く確率を $p(i, j)$ とし、$i$ 番目の人が $j$ 番目の人に勝つ確率を $q(i, j)$ とすると、

\[ q(i, j) = \frac{S_i^2}{S_i^2 + S_j^2} \]
\[ p(i, j) = p(i, j - 1) \sum_{T}^{k} q(i, k) \cdot p(k, j - 1) \]

となる。ただし、$T$ は $i$ 番目の人が $j$ 回戦で対戦する可能性のある相手の集合である。

これを1回戦から順に計算し、$p(0, M)$ を見る。

** No.67

長さ $L$ の棒が $K$ 本以上できるかどうかを調べる。

$L$ は二分探索で探す。

** No.69

文字をソートして比較する。

** No.70

時刻を分に変換して計算する。

** No.71

$N$ 個の珠を $x$, $N-x$ 個に分けたとき、表せる状態の数 $S$ は $S = (x + 1)(N - x + 1)$ である。

$S$ が最大になる $x$ を求める。

あとはこれを全探索で求めてもいいし、No.72 のように解いてもいい。

** No.72

$S$ が最大になる $x$ を求めるまでは No.71 と同様である。ただし、制限が厳しいので全探索は使えない。そこで、

\begin{align*}
S &= (x + 1)(N - x + 1) \\
  &= -x^2 + Nx + N + 1 \\
  &= -\biggl(x - \frac{N}{2}\biggr) + \frac{N^2}{4} + N + 1
\end{align*}

となるので、$S$ は $x = N/2$ のときに最大となる。ただし、$x$ は整数でなければならないので、$N \equiv 1 \pmod{2}$ のときは、$S$ は $x = \lfloor N/2 \rfloor$ のときに最大となる。

** No.73

h,e,l,o,w,r,d 以外の文字は helloworld 数には寄与しないので無視する。helloworld 数は

\[ \prod_{k=1}^{9} j_k \]

となる。ただし $j_k$ は $i_k$ の組み合わせの数である。

h,e,w,r,d のような helloworld 中に1度しか登場しない文字については、たとえば $j_0 = C_h$ のときに最大化できる。

o については、$j_4j_6 = x(C_o - x)$ を最大にするように $x$ を決めればいい。

l については、$j_{2,3}j_8 = {}_{y} C_2 (C_l - y)$ を最大にするように $y$ を決めればいい。

$x,y$ はそれぞれ全探索で求める。

** No.74

コインの状態を表が1、裏が0として、これをベクトル $\bf{a}$ で表現する。

このとき、$i$ 番目のコインを選んでそのコインの $\pm d$ 隣を裏返す操作は、$i \pm d$ 番目の要素が1であるベクトルを $\boldsymbol{b_i}$ とすると、$\boldsymbol{a} \oplus \boldsymbol{b_i}$ となる。

排他的論理和の性質から、コインを選ぶ順序は順不同であり、また2回以上同じコインを選ぶ意味はない。

初期状態を $\boldsymbol{c}$ 、最終状態を $\boldsymbol{d}$ とすると、

\[ \boldsymbol{d} = \boldsymbol{c} + (\boldsymbol{b_1} \ \boldsymbol{b_2} \ \cdots \ \boldsymbol{b_N})\boldsymbol{x} \]

となる $\boldsymbol{x}$ が存在すれば、コインをすべて表にすることができる。$\boldsymbol{x}$ が存在するどうかは掃き出し法で求める。

** No.75

それまでに出た目の合計が $x$ のとき、そこからちょうど $K$ に達するためにふるサイコロの回数の期待値を $E(x)$ とする。このとき、

\[ E(x) = \sum_{d=1}^6 1/6E(x+d) + 1 \]

となる。ただし、

\[ E(K) = 0, \ \forall a \gt K, E(a) = E(0) \]

である。

$\forall a > K, E(a) = m$ と置いて $E(K-1)$ から $E(K-2), E(K-3), \cdots$ を順に計算していき、この結果得られた $E(0)$ と $m$ の差が誤差範囲に収まるよう、二分探索で $m$ を探索する。

** No.76

$i$ の目が出る確率を $p_i$ として、残り出目の和が $x$ のときのそこから振るサイコロの回数の期待値を $E(x)$ とすると、

\[ E(x) = \sum_{d = 1}^6 p_dE(x - d) + 1 \]

となる。ただし、$\forall a \leq 0, E(a) = 0$ である。

サンプルから、

\begin{align*}
E(1) &= 1 \\
E(2) &= p_1E(1) + 1                     &= 1.0833333333333333 \\
E(3) &= p_1E(2) + p_2E(1) + 1           &= 1.2569444444444444 \\
E(4) &= p_1E(3) + p_2E(2) + p_3E(1) + 1 &= 1.5353009259259260
\end{align*}

のようになり、ここから $p_i \ (1 \leq i \leq 5)$ を求めることができる。$p_6$ は、$p_6 = 1 - \sum p_i \ (1 \leq i \leq 5)$ で求められる。

あとは $E(N)$ を求めればいい。

** No.77

ピラミッド列の列数を $n$ とすると、ピラミッド列の $i$ 列目のレンガの数 $S_i$ は、

\begin{align*}
S_i &= i         & i \leq \frac{n+1}{2} \\
S_i &= n - i + 1 & i \gt \frac{n+1}{2}
\end{align*}

となる。初期配置のレンガの数がピラミッド列のレンガの数より多い列に着目し、その差の合計が移動回数となる。(レンガは多い列から少ない列に移動するか、多い列から捨てるかしかないため)

なお、初期で配置されているレンガの総数が必要なレンガの総数より少ない場合はピラミッド列は作れない。必要なレンガの総数 $S$ は、

\begin{align*}
S &= \sum S_i = 2\frac{\frac{n+1}{2}\frac{n-1}{2}}{2} + \frac{n+1}{2} \\
  &= \frac{n^2-1+2(n+1)}{4} \\
  &= \frac{(n+1)^2}{4}
\end{align*}

となり、$n$ は高々 100 程度となるので、全探索する。

** No.78

1箱目の $i$ 番目のアイスを手に入れるために必要な購入数 $n_i$ をシミュレーションで求めておく。また、1箱目のアイスをすべて手に入れたときの手持ちのあたりの数 $k$ も求めておく。

2箱目以降は $i$ 番目のアイスを手に入れるために必要な購入数は $n_i - k$ で求められる。ただし、$n_i - k \lt 0$ のときは $0$ とする。

** No.79

実装あるのみ。

** No.80

四角形の縦の長さを $L_v$ 、横の長さを $L_h$ とすると、$L_v + L_h = \lfloor D/2 \rfloor$ となればいい。

$D/2$ は 5000 程度なので、全探索で面積が最大となる $L_v, L_h$ を求める。

** No.81

$10^10$ 倍して BigInt で計算する。

** No.82

実装あるのみ。無限リストが使えると楽に書ける。

** No.83

数字は 1 と 7 しか使わない。他の数字を使うより、1 を2つ並べる方が大きな数を作れる。

$N$ が偶数のときは 1 を単純に並べて、$N$ が奇数のときは最初が 7 で残りは 1 を並べる。

** No.84

珠がない格子点の候補を考える。

原点を四角形の中心として、四角形を各辺が

正方形のときは、第一象限の格子点が使える。また、$R$ が奇数のときは、$x \geq 0$ の $x$ 軸上の格子点も使える。

長方形のときは、$y > 0$ の格子点が使える。また、$R$ が奇数のときは、$x \geq 0$ の $x$ 軸上の格子点も使える。

残りの格子点は回転させると使用済の格子点に重なるので使えない。

** No.85

$N = 1$ のときは、$M=2$ ならは可能である。$M = 1$ の場合も同様である。

そうでない場合、$N, M$ のいずれかが偶数であれば可能である。$N, M$ がともに奇数であれば不可能である。

$X_0, Y_0$ からスタートしたとすると、偶数歩歩いたときに $(X_0 + Y_0 \equiv X + Y \pmod 2) となる。

$N, M$ がいずれも奇数の場合は $NM$ も奇数であり、すべてのマスを辿ったあとに元のマスに戻るためには奇数歩だけ歩く必要がある。これは上記の条件から不可能である。

** No.87

うるう年は400年周期なので、7月23日の曜日は2800年周期となる。

よって、2800年分の7月23日の曜日を計算しておき、$N - 2014$ を $2800$ で割った商の分と余りの分で分けて求める。

** No.88

石の数を数えて、偶数なら先手番、奇数なら後手番となる。

** No.89

バップス・ギュルタンの定理を使って実装あるのみ。

** No.90

商品の順序の組み合わせは $9!$ で、ひとつの順序につきスコアの計算が $9^2$ なので、 $9!9^2 \sim 3\cdot10^7$ であるから、全探索でも可能である。

** Local variables                                                 :noexport:

# Local variables:
# after-save-hook: org-html-export-to-html
# end:
