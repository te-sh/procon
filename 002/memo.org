#+OPTIONS: num:nil author:nil timestamp:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

# Local variables:
# after-save-hook: org-html-export-to-html
# end:

** No.51

実装あるのみ。

制約から $D^2$ が =int= を超える可能性があるので =long= を使う。

** No.52

$k$ 回目に前から取るか後ろから取るかで全探索する。

** No.55

$P_1(X1, Y1), P_2(X2, Y2), P_3(X3, Y3)$ とする。

$P_1,P_2,P_3$ の順序を入れ替えて、すべての入れ替えパターンで正方形が1つでもできるかどうかを調べる。

$\vec{v_1}=\overrightarrow{P_1P_2}$, $\vec{v_2}=\overrightarrow{P_2P_3}$ とすると、正方形ができるためには次の条件が成り立つ必要がある。

\[ |\vec{v_1}| = |\vec{v_2}| \]

\[ \vec{v_1} \cdot \vec{v_2} = 0 \]

このとき、$P_1, P_4$ の位置ベクトルを $\vec{p_1}, \vec{p_4}$ とすると、

\[ \vec{p_4} = \vec{p_1} + \vec{v_2} \]

となる。

** No.56

\(D(100 + P) / 100\) で求められる。

$D (100 + P)$ が =int= を超える可能性があるので =long= を使う。

** No.57

1つのサイコロを振ったときの出る目の期待値は $3.5$ である。

各サイコロは独立なので、$N$ 個のサイコロを振った時に出る目の和の合計の期待値は各サイコロを振った時の目の和の期待値の合計 $3.5N$ となる。

** No.58

モンテカルロ法を使って実装あるのみ。

** No.59

Binary Indexed Tree (BIT) を使う。

インデックスには荷物の重さを使い、重さ $W$ の荷物を積む(降ろす)ときには BIT のインデックス $W$ を +1(-1) する。

** No.60

各位置ごとに合計でどれだけの攻撃があったかを imos 法で計算しておく。

その後、モンスターごとに HP が残るかどうかを調べ、残るならその合計を計算する。

** No.61

空間を下のように折り返して上下左右ともに2倍に拡張する。

|------------+--------------|
| 上下反転   | 上下左右反転 |
| オリジナル | 左右反転     |
|------------+--------------|

ただし、左右の端および上下の端はつながっているものとする。こうすることで反射を考えなくてもよくなる。

次に、$V_x,V_y$ を $g = \gcd(V_x, V_y)$ で割り、$D$ を $g$ 倍しておく。これで単位時間ごとに軌道上の格子点をすべて通るようになる。

あとはシミュレーションを行い、時間 $D$ 内にどの格子点を通るか調べればいい。ただし、すでに通った点にたどり着いた場合は以降も同じ軌道を通るのでシミュレーションを打ち切る。

** No.63

$L$ が2で割り切れない場合または $L/2$ が $K$ で割り切れない場合は、$\lfloor \lfloor L/2 \rfloor /K \rfloor$ 回かじる。

そうでない場合は1回少なくかじる。

** No.64

\begin{align*}
F_{k+3} &= F_{k+2} \oplus F_{k+1} \\
        &= (F_{k+1} \oplus F_{k}) \oplus F_{k+1} \\
        &= (F_{k+1} \oplus F_{k+1}) \oplus F_{k} \\
        &= F_{k}
\end{align*}

となるので、$F_k$ は周期3で循環している。

** No.65

問題に書かれている計算式にしたがって計算する。

** No.66

$i$ 番目の人が $j$ 回戦を勝ち抜く確率を $p(i, j)$ とし、$i$ 番目の人が $j$ 番目の人に勝つ確率を $q(i, j)$ とすると、

\[ q(i, j) = \frac{S_i^2}{S_i^2 + S_j^2} \]
\[ p(i, j) = p(i, j - 1) \sum_{T}^{k} q(i, k) \cdot p(k, j - 1) \]

となる。ただし、$T$ は $i$ 番目の人が $j$ 回戦で対戦する可能性のある相手の集合である。

これを1回戦から順に計算し、$p(0, M)$ を見る。

** No.67

長さ $L$ の棒が $K$ 本以上できるかどうかを調べる。

$L$ は二分探索で探す。

** No.69

文字をソートして比較する。

** No.70

時刻を分に変換して計算する。

** No.71

$N$ 個の珠を $x$, $N-x$ 個に分けたとき、表せる状態の数 $S$ は $S = (x + 1)(N - x + 1)$ である。

$S$ が最大になる $x$ を求める。

あとはこれを全探索で求めてもいいし、No.72 のように解いてもいい。

** No.72

$S$ が最大になる $x$ を求めるまでは No.71 と同様である。ただし、制限が厳しいので全探索は使えない。そこで、

\begin{align*}
S &= (x + 1)(N - x + 1) \\
  &= -x^2 + Nx + N + 1 \\
  &= -\biggl(x - \frac{N}{2}\biggr) + \frac{N^2}{4} + N + 1
\end{align*}

となるので、$S$ は $x = N/2$ のときに最大となる。ただし、$x$ は整数でなければならないので、$N \equiv 1 \pmod{2}$ のときは、$S$ は $x = \lfloor N/2 \rfloor$ のときに最大となる。

** No.73

h,e,l,o,w,r,d 以外の文字は helloworld 数には寄与しないので無視する。helloworld 数は

\[ \prod_{k=1}^{9} j_k \]

となる。ただし $j_k$ は $i_k$ の組み合わせの数である。

h,e,w,r,d のような helloworld 中に1度しか登場しない文字については、たとえば $j_0 = C_h$ のときに最大化できる。

o については、$j_4j_6 = x(C_o - x)$ を最大にするように $x$ を決めればいい。

l については、$j_{2,3}j_8 = {}_{y} C_2 (C_l - y)$ を最大にするように $y$ を決めればいい。

$x,y$ はそれぞれ全探索で求める。

** No.74

コインの状態を表が1、裏が0として、これをベクトル $\bf{a}$ で表現する。

このとき、$i$ 番目のコインを選んでそのコインの $\pm d$ 隣を裏返す操作は、$i \pm d$ 番目の要素が1であるベクトルを $\boldsymbol{b_i}$ とすると、$\boldsymbol{a} \oplus \boldsymbol{b_i}$ となる。

排他的論理和の性質から、コインを選ぶ順序は順不同であり、また2回以上同じコインを選ぶ意味はない。

初期状態を $\boldsymbol{c}$ 、最終状態を $\boldsymbol{d}$ とすると、

\[ \boldsymbol{d} = \boldsymbol{c} + (\boldsymbol{b_1} \ \boldsymbol{b_2} \ \cdots \ \boldsymbol{b_N})\boldsymbol{x} \]

となる $\boldsymbol{x}$ が存在すれば、コインをすべて表にすることができる。$\boldsymbol{x}$ が存在するどうかは掃き出し法で求める。
